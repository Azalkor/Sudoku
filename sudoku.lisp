(defvar SIZE 3)
(defvar AREA (* SIZE SIZE))
(defvar find 1)

;;init grille
(defparameter *grid*
  #2A((1 0 0 0 0 4 0 0 5)
      (0 0 0 9 5 0 0 8 0)
      (0 0 0 0 0 3 0 9 0)
      (0 0 5 0 0 2 0 0 4)
      (0 0 1 0 6 0 7 0 0)
      (7 0 0 3 0 0 2 0 0)
      (0 6 0 5 0 0 0 0 0)
      (0 8 0 0 1 6 0 0 0)
      (5 0 0 2 0 0 0 0 7)))

;;fonction qui nous affiche la grille
(defun sudoku() 
  (format t "   | A B C | D E F | G H I |~C" #\linefeed)
  (dotimes(tmp (+ (* AREA SIZE) 1))
    (format t "-"))
  (dotimes (l AREA)
    (format t "~C ~D | " #\linefeed (+ l 1))
    (dotimes (c AREA)
      (let ((nb (aref *grid* l c)))
	(if (zerop (mod (+ c 1) SIZE))
	    (if (zerop nb)
		(format t "  | ")
		(format t "~D | " nb))
	    (if (zerop nb)
		(format t "  ")
		(format t "~D " nb)))))
    (if (zerop (mod (+ l 1) SIZE))
	(progn 
	  (format t "~C" #\linefeed)
	  (dotimes (tmp (+ (* AREA SIZE) 1))
	    (format t "-")))
	NIL)))

;;On demande au joueur de choisir la ligne la colonne et la valeur d'un case
(defun user-read ()
  (let ((l (progn (princ "ligne (entier) ? ") (read)))
	(c (progn (princ "colonne (lettre) ? ") (read)))
	(val (progn (princ "valeur ? ") (read))))
    (if (not-correct (- l 1) (- c 1) val)
	(progn 
	  (format t "valeur existante ligne et/ou colonne et/ou 3x3~C" #\linefeed)
	  (user-read))
	(setf (aref *grid* (- l 1) (- c 1)) val))))

;;On vÃ©rifie si la valeur, la ligne et la colonne sont correct
(defun not-correct (l c val)
  (if (or (>= 0 val) (> val AREA) (> 0 l) (> l (- AREA 1)) (> 0 c) (> c (- AREA 1)))
      T
      (dotimes (tmpLC AREA)
	(if (or (= (aref *grid* tmpLC c) val) (= (aref *grid* l tmpLC) val))
	    (return-from not-correct T)
	    (dotimes (tmpL SIZE)
	      (dotimes (tmpC SIZE)
		(cond ((< l SIZE)
		       (cond ((and (< c SIZE) (>= c 0) (= (aref *grid* tmpL tmpC) val))
			      (return-from not-correct T))
			     ((and (< c (* SIZE 2)) (>= c SIZE)(= (aref *grid* tmpL (+ tmpC SIZE)) val))
			      (return-from not-correct T))
			     ((and (< c AREA) (>= c (* SIZE 2)) (= (aref *grid* tmpL (+ tmpC (* SIZE 2))) val))
			      (return-from not-correct T))
			     (T NIL)))
		      ((< l (* SIZE 2))
		       (cond ((and (< c SIZE) (>= c 0) (= (aref *grid* (+ tmpL SIZE) tmpC) val))
			      (return-from not-correct T))
			     ((and (< c (* SIZE 2)) (>= c SIZE)(= (aref *grid* (+ tmpL SIZE) (+ tmpC SIZE)) val))
			      (return-from not-correct T))
			     ((and (< c AREA) (>= c (* SIZE 2)) (= (aref *grid* (+ tmpL SIZE) (+ tmpC (* SIZE 2))) val))
			      (return-from not-correct T))
			     (T NIL)))
		      (T
		       (cond ((and (< c SIZE) (>= c 0) (= (aref *grid* (+ tmpL (* SIZE 2)) tmpC) val))
			      (return-from not-correct T))
			     ((and (< c (* SIZE 2)) (>= c SIZE)(= (aref *grid* (+ tmpL (* SIZE 2)) (+ tmpC SIZE)) val))
			      (return-from not-correct T))
			     ((and (< c AREA) (>= c (* SIZE 2)) (= (aref *grid* (+ tmpL (* SIZE 2)) (+ tmpC (* SIZE 2))) val))
			      (return-from not-correct T))
			     (T NIL))))))))))

(defun game-over()
  (dotimes (tmpL 9)
    (dotimes (tmpC 9)
      (when (/= (aref *grid* tmpL tmpC) 0)
	  (dotimes (tmpVal 9)
	    (when (not (not-correct tmpL tmpC (+ tmpVal 1)))
	      (return NIL))
	    (return-from game-over T)))
	  )))
  T)

(defun main ()
  (if (game-over)
      (format t "perdu !~C" #\linefeed)
      (progn
	(sudoku)
	(format t "~C" #\linefeed)
	(user-read)
	(main))))