;;init grille
;(defparameter *grid*
;  #2A((1 0 0 0 0 4 0 0 5)
;      (0 0 0 9 5 0 0 8 0)
;      (0 0 0 0 0 3 0 9 0)
;      (0 0 5 0 0 2 0 0 4)
;      (0 0 1 0 6 0 7 0 0)
;      (7 0 0 3 0 0 2 0 0)
;      (0 6 0 5 0 0 0 0 0)
;      (0 8 0 0 1 6 0 0 0)
;      (5 0 0 2 0 0 0 0 7)))

(defparameter *grid*
  #2A((7 0 2 0 3 0 0 0 5)
      (9 0 5 7 0 0 0 0 1)
      (1 3 0 0 0 8 0 0 0)
      (0 0 0 5 8 2 9 0 3)
      (0 0 0 0 0 0 0 0 2)
      (0 0 0 0 0 0 6 0 7)
      (0 0 0 0 0 5 0 9 0)
      (0 6 7 0 0 0 1 0 0)
      (3 0 9 4 7 0 0 0 0)))

;(defparameter *grid*
;  #2A((4 0 0 0)
;      (0 3 0 0)
;      (0 0 0 3)
;      (0 0 4 1)))

;(defparameter *grid*
 ; #2A((4 1 3 2)
  ;    (2 3 1 4)
   ;   (0 4 2 3)
    ;  (3 2 4 1)))


(defparameter SIZE (truncate (sqrt (array-dimension *grid* 0))))
(defparameter AREA (* SIZE SIZE))

;;fonction qui nous affiche la grille
(defun sudoku()
  (format t "   | ")
  (dotimes (tmp AREA)
    (if (zerop (mod (+ tmp 1) SIZE))
	(format t "~D | " (code-char (+ tmp (char-code #\A))))
	(format t "~D " (code-char (+ tmp (char-code #\A))))))
  (format t "~C" #\linefeed)
  (dotimes(tmp (+ 2 (* 2 (+ SIZE 1)) (* 2 AREA)))
    (format t "-"))
  (dotimes (l AREA)
    (format t "~C ~D | " #\linefeed (+ l 1))
    (dotimes (c AREA)
      (let ((nb (aref *grid* l c)))
	(if (zerop (mod (+ c 1) SIZE))
	    (if (zerop nb)
		(format t "  | ")
		(format t "~D | " nb))
	    (if (zerop nb)
		(format t "  ")
		(format t "~D " nb)))))
    (if (zerop (mod (+ l 1) SIZE))
	(progn 
	  (format t "~C" #\linefeed)
	  (dotimes (tmp (+ 2 (* 2 (+ SIZE 1)) (* 2 AREA)))
	    (format t "-")))
	NIL)))

;;On demande au joueur de choisir la ligne la colonne et la valeur d'une case
(defun user-read ()
  (let ((l (progn (princ "ligne (entier) ? ") (read)))
	(c (progn (princ "colonne (lettre) ? ") (read-char)))
	(val (progn (princ "valeur ? ") (read))))
    (if (and (>= (char-code c) (char-code #\A)) (< (char-code c) (char-code #\a)))
	(setf c (- (char-code c) (- (char-code #\A) 1))) ;conversion Lettres -> Chiffres
	(setf c (- (char-code c) (- (char-code #\a) 1))))
    (if (not-correct (- l 1) (- c 1) val)
	(progn 
	  (format t "valeur existante ligne et/ou colonne et/ou 3x3~C" #\linefeed)
	  (user-read))
	(if (= (aref *grid* (- l 1) (- c 1)) 0)
	    (progn 
	      (format t "Case occupée~C" #\linefeed)
	      (user-read))
	    (setf (aref *grid* (- l 1) (- c 1)) val)))))

;;On vérifie si la valeur, la ligne et la colonne sont correctes
(defun not-correct (l c val)
  (if (or (>= 0 val) (> val AREA) (> 0 l) (> l (- AREA 1)) (> 0 c) (> c (- AREA 1)))
      T
      (dotimes (tmpLC AREA)
	(if (or (= (aref *grid* tmpLC c) val) (= (aref *grid* l tmpLC) val))
	    (return-from not-correct T)
	    (dotimes (tmpL SIZE)
	      (dotimes (tmpC SIZE)
		(cond ((< l SIZE)
		       (cond ((and (< c SIZE) (>= c 0) (= (aref *grid* tmpL tmpC) val))
			      (return-from not-correct T))
			     ((and (< c (* SIZE 2)) (>= c SIZE)(= (aref *grid* tmpL (+ tmpC SIZE)) val))
			      (return-from not-correct T))
			     ((and (< c AREA) (>= c (* SIZE 2)) (= (aref *grid* tmpL (+ tmpC (* SIZE 2))) val))
			      (return-from not-correct T))
			     (T NIL)))
		      ((< l (* SIZE 2))
		       (cond ((and (< c SIZE) (>= c 0) (= (aref *grid* (+ tmpL SIZE) tmpC) val))
			      (return-from not-correct T))
			     ((and (< c (* SIZE 2)) (>= c SIZE)(= (aref *grid* (+ tmpL SIZE) (+ tmpC SIZE)) val))
			      (return-from not-correct T))
			     ((and (< c AREA) (>= c (* SIZE 2)) (= (aref *grid* (+ tmpL SIZE) (+ tmpC (* SIZE 2))) val))
			      (return-from not-correct T))
			     (T NIL)))
		      (T
		       (cond ((and (< c SIZE) (>= c 0) (= (aref *grid* (+ tmpL (* SIZE 2)) tmpC) val))
			      (return-from not-correct T))
			     ((and (< c (* SIZE 2)) (>= c SIZE)(= (aref *grid* (+ tmpL (* SIZE 2)) (+ tmpC SIZE)) val))
			      (return-from not-correct T))
			     ((and (< c AREA) (>= c (* SIZE 2)) (= (aref *grid* (+ tmpL (* SIZE 2)) (+ tmpC (* SIZE 2))) val))
			      (return-from not-correct T))
			     (T NIL))))))))))

(defun game-over()
  (dotimes (tmpL AREA)
    (dotimes (tmpC AREA)
      (when (= (aref *grid* tmpL tmpC) 0)
	  (dotimes (tmpVal AREA)
	    (when (not (not-correct tmpL tmpC (+ tmpVal 1)))
	      (return NIL))
	    (when (= tmpVal (- AREA 1))
	      (format t "~CGame Over : aucune possibilité restante pour la case (~D-~D) !~C" #\linefeed tmpL tmpC #\linefeed)
	      (return-from game-over T))))))
  NIL)

(defun win()
  (dotimes (tmpL AREA)
    (dotimes (tmpC AREA)
      (when (= (aref *grid* tmpL tmpC) 0)
	(return-from win NIL))
      ))
  T)

(defun main ()
  (sudoku)
  (when (not(game-over))
    (format t "~C" #\linefeed)
    (if (not(win))
	(progn
	  (user-read)
	  (main))
	(format t "Vous avez gagné, bien joué !~C" #\linefeed))))
  
(defun random-strategy()
  (when (not(game-over))
    (format t "~C" #\linefeed)
    (if (not(win))
	(progn	  
	  (let ((l (random AREA))
		(c (random AREA))
		(val (+ (random AREA) 1)))
	    (format t "l:~D c:~D val:~D ~C" l c val #\linefeed)
	    (when (not (not-correct l c val))
	      (setf (aref *grid* l c) val)
	      (sudoku))
	    (random-strategy)))
	(format t "Vous avez gagné, bien joué !~C" #\linefeed))))

(defun int-strategy()
  (when (not(game-over))
    (if (not(win))
	(dotimes (val AREA) 
	  (dotimes (l AREA)
	    (let ((possibilities 0)
		  (lastC 0))
	      (dotimes (c AREA)
		(when (zerop (aref *grid* l c))
		  (when (not (not-correct l c (+ val 1)))
		    (setf possibilities (+ possibilities 1))
		    (setf lastC c))))
		(when (= possibilities 1)
		  (setf (aref *grid* l lastC) (+ val 1))
		  (int-strategy)))))
	(progn
	  (sudoku)
	  (format t "~CVous avez gagné, bien joué !~C" #\linefeed #\linefeed)))))
