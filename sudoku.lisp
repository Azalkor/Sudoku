;;Le programme supporte des grilles carrées d'une taille maximale de 9*9

(defparameter *grid*
  #2A((1 2 0 0 0 4 0 0 5)
      (0 0 0 9 5 0 0 8 0)
      (0 0 0 0 0 3 0 9 0)
      (0 0 5 0 0 2 0 0 4)
      (0 0 1 0 6 0 7 0 0)
      (7 0 0 3 0 0 2 0 0)
      (0 6 0 5 0 0 0 0 0)
      (0 8 0 0 1 6 0 0 0)
      (5 0 0 2 0 0 0 0 7)))

;(defparameter *grid*
;  #2A((7 0 2 0 3 0 0 0 5)
;      (9 0 5 7 0 0 0 0 1)
;      (1 3 0 0 0 8 0 0 0)
;      (0 0 0 5 8 2 9 0 3)
;      (0 0 0 0 0 0 0 0 2)
;      (0 0 0 0 0 0 6 0 7)
;      (0 0 0 0 0 5 0 9 0)
;      (0 6 7 0 0 0 1 0 0)
;      (3 0 9 4 7 0 0 0 0)))

;(defparameter *grid*
;  #2A((4 0 0 0)
;      (0 3 0 0)
;      (0 0 0 3)
;      (0 0 4 1)))


(defparameter SIZE (truncate (sqrt (array-dimension *grid* 0)))) ; côté d'un bloc
(defparameter AREA (* SIZE SIZE)) ; côté de la grille

;;fonction qui nous affiche la grille
(defun sudoku()
  (format t "~C   | " #\linefeed)
  (dotimes (tmp AREA)
    (if (zerop (mod (+ tmp 1) SIZE))
	(format t "~D | " (code-char (+ tmp (char-code #\A)))) ; conversion lettres -> chiffres
	(format t "~D " (code-char (+ tmp (char-code #\A))))))
  (format t "~C" #\linefeed)
  (dotimes(tmp (+ 2 (* 2 (+ SIZE 1)) (* 2 AREA)))
    (format t "-"))
  (dotimes (l AREA)
    (format t "~C ~D | " #\linefeed (+ l 1))
    (dotimes (c AREA)
      (let ((nb (aref *grid* l c)))
	(if (zerop (mod (+ c 1) SIZE))
	    (if (zerop nb)
		(format t "  | ")
		(format t "~D | " nb))
	    (if (zerop nb)
		(format t "  ")
		(format t "~D " nb)))))
    (if (zerop (mod (+ l 1) SIZE))
	(progn 
	  (format t "~C" #\linefeed)
	  (dotimes (tmp (+ 2 (* 2 (+ SIZE 1)) (* 2 AREA)))
	    (format t "-")))
	NIL)))

;;On demande au joueur de choisir la ligne la colonne et la valeur d'une case
(defun user-read ()
  (let ((l (progn (princ "ligne (entier) ? ") (read)))
	(c (progn (princ "colonne (lettre) ? ") (read-char)))
	(val (progn (princ "valeur ? ") (read))))
    (if (and (>= (char-code c) (char-code #\A)) (< (char-code c) (char-code #\a))) ; gestion de la casse
	(setf c (- (char-code c) (- (char-code #\A) 1))) ; conversion lettres -> chiffres
	(setf c (- (char-code c) (- (char-code #\a) 1))))
    (if (not-correct (- l 1) (- c 1) val)
	(progn 
	  (format t "valeur existante ligne et/ou colonne et/ou 3x3~C" #\linefeed)
	  (user-read))
	(if (/= (aref *grid* (- l 1) (- c 1)) 0)
	    (progn 
	      (format t "Case occupée~C" #\linefeed)
	      (user-read))
	    (setf (aref *grid* (- l 1) (- c 1)) val)))))

;;On vérifie si la valeur, la ligne et la colonne sont correctes
;les chiffres doivent être dans la bonne tranche de valeurs
;on applique les trois règles du sudoku (recherche de doublons sur chaque ligne, colonne puis chaque bloc)
(defun not-correct (l c val)
  (if (or (>= 0 val) (> val AREA) (> 0 l) (> l (- AREA 1)) (> 0 c) (> c (- AREA 1)))
      T
      (dotimes (tmpLC AREA)
	(if (or (= (aref *grid* tmpLC c) val) (= (aref *grid* l tmpLC) val))
	    (return-from not-correct T)
	    (dotimes (tmpL SIZE)
	      (dotimes (tmpC SIZE)
		(cond ((< l SIZE)
		       (cond ((and (< c SIZE) (>= c 0) (= (aref *grid* tmpL tmpC) val))
			      (return-from not-correct T))
			     ((and (< c (* SIZE 2)) (>= c SIZE)(= (aref *grid* tmpL (+ tmpC SIZE)) val))
			      (return-from not-correct T))
			     ((and (< c AREA) (>= c (* SIZE 2)) (= (aref *grid* tmpL (+ tmpC (* SIZE 2))) val))
			      (return-from not-correct T))
			     (T NIL)))
		      ((< l (* SIZE 2))
		       (cond ((and (< c SIZE) (>= c 0) (= (aref *grid* (+ tmpL SIZE) tmpC) val))
			      (return-from not-correct T))
			     ((and (< c (* SIZE 2)) (>= c SIZE)(= (aref *grid* (+ tmpL SIZE) (+ tmpC SIZE)) val))
			      (return-from not-correct T))
			     ((and (< c AREA) (>= c (* SIZE 2)) (= (aref *grid* (+ tmpL SIZE) (+ tmpC (* SIZE 2))) val))
			      (return-from not-correct T))
			     (T NIL)))
		      (T
		       (cond ((and (< c SIZE) (>= c 0) (= (aref *grid* (+ tmpL (* SIZE 2)) tmpC) val))
			      (return-from not-correct T))
			     ((and (< c (* SIZE 2)) (>= c SIZE)(= (aref *grid* (+ tmpL (* SIZE 2)) (+ tmpC SIZE)) val))
			      (return-from not-correct T))
			     ((and (< c AREA) (>= c (* SIZE 2)) (= (aref *grid* (+ tmpL (* SIZE 2)) (+ tmpC (* SIZE 2))) val))
			      (return-from not-correct T))
			     (T NIL))))))))))

;;On vérifie qu'il reste toujours au moins une possibilité pour chaque case à remplir
(defun game-over()
  (dotimes (tmpL AREA)
    (dotimes (tmpC AREA)
      (when (= (aref *grid* tmpL tmpC) 0)
	  (dotimes (tmpVal AREA)
	    (when (not (not-correct tmpL tmpC (+ tmpVal 1)))
	      (return NIL))
	    (when (= tmpVal (- AREA 1))
	      (format t "~CGame Over : aucune possibilité restante pour la case ~D~D !~C" #\linefeed (code-char (+ tmpC (char-code #\A))) (+ tmpL 1) #\linefeed)
	      (return-from game-over T))))))
  NIL)

(defun win()
  (dotimes (tmpL AREA)
    (dotimes (tmpC AREA)
      (when (= (aref *grid* tmpL tmpC) 0)
	(return-from win NIL))
      ))
  T)

(defun main ()
  (sudoku)
  (when (not(game-over))
    (format t "~C" #\linefeed)
    (if (not(win))
	(progn
	  (user-read)
	  (main))
	(format t "Vous avez gagné, bien joué !~C" #\linefeed))))

;; On ajoute une valeur aléatoire dans une case libre aléatoire
(defun random-strategy()
  (if (not(game-over))
      (if (not(win))
	  (progn	  
	    (let ((l (random AREA))
		  (c (random AREA))
		  (val (+ (random AREA) 1)))
	      (when (and (not (not-correct l c val)) (zerop (aref *grid* l c)))
		(setf (aref *grid* l c) val))
	      (random-strategy)))
	  (progn
	    (sudoku)
	    (format t "Vous avez gagné, bien joué !~C" #\linefeed)))
      (sudoku)))

;; On parcours pour chaque valeur, ligne par ligne
(defun line-strategy()
  (dotimes (val AREA) 
    (dotimes (l AREA)
      ;la variable possibilities compte le nombre de case qui peuvent contenir la valeur en cours.
      ;ainsi, on ne peut être sûr de notre case que si possibilities vaut 1 à la fin du parcours.
      (let ((possibilities 0)
	    (lastC 0))
	(dotimes (c AREA)
	  (when (zerop (aref *grid* l c))
	    (when (not (not-correct l c (+ val 1)))
	      (setf possibilities (+ possibilities 1))
	      (setf lastC c))))
	(when (= possibilities 1)
	  (setf (aref *grid* l lastC) (+ val 1))
	  (return-from line-strategy T)))))
  NIL)

;; On parcours pour chaque valeur, colonne par colonne
(defun col-strategy()
  (dotimes (val AREA) 
    (dotimes (c AREA)
      (let ((possibilities 0)
	    (lastL 0))
	(dotimes (l AREA)
	  (when (zerop (aref *grid* l c))
	    (when (not (not-correct l c (+ val 1)))
	      (setf possibilities (+ possibilities 1))
	      (setf lastL l))))
	(when (= possibilities 1)
	  (setf (aref *grid* lastL c) (+ val 1))
	  (return-from col-strategy T)))))
  NIL)

;; On parcours pour chaque valeur, bloc par bloc
(defun square-strategy()
  (dotimes (val AREA)
    (dotimes (l AREA)
      (dotimes (c AREA)
	(when (zerop (aref *grid* l c))
	  (let ((possibilities 0)
		(lastL 0)
		(lastC 0))
	    (dotimes (tmpL SIZE)
	      (dotimes (tmpC SIZE)
		(cond ((< l SIZE)
		       (cond ((and (< c SIZE) (>= c 0) (zerop (aref *grid* tmpL tmpC)))
			      (when (not (not-correct tmpL tmpC (+ val 1)))
				(setf possibilities (+ possibilities 1))
				(setf lastL tmpL)
				(setf lastC tmpC)))
			     ((and (< c (* SIZE 2)) (>= c SIZE)(zerop (aref *grid* tmpL (+ tmpC SIZE))))
			      (when (not (not-correct tmpL (+ tmpC SIZE) (+ val 1)))
				(setf possibilities (+ possibilities 1))
				(setf lastL tmpL)
				(setf lastC (+ tmpC SIZE))))
			     ((and (< c AREA) (>= c (* SIZE 2)) (zerop (aref *grid* tmpL (+ tmpC (* SIZE 2)))))
			      (when (not (not-correct tmpL (+ tmpC (* SIZE 2)) (+ val 1)))
				(setf possibilities (+ possibilities 1))
				(setf lastL tmpL)
				(setf lastC (+ tmpC (* SIZE 2)))))
			     (T NIL)))
		      ((< l (* SIZE 2))
		       (cond ((and (< c SIZE) (>= c 0) (zerop (aref *grid* (+ tmpL SIZE) tmpC)))
			      (when (not (not-correct ( + tmpL SIZE) tmpC (+ val 1)))
				(setf possibilities (+ possibilities 1))
				(setf lastL ( + tmpL SIZE))
				(setf lastC tmpC)))
			     ((and (< c (* SIZE 2)) (>= c SIZE)(zerop (aref *grid* (+ tmpL SIZE) (+ tmpC SIZE))))
			      (when (not (not-correct ( + tmpL SIZE) (+ tmpC SIZE) (+ val 1)))
				(setf possibilities (+ possibilities 1))
				(setf lastL ( + tmpL SIZE))
				(setf lastC ( + tmpC SIZE))))
			     ((and (< c AREA) (>= c (* SIZE 2)) (zerop (aref *grid* (+ tmpL SIZE) (+ tmpC (* SIZE 2)))))
			      (when (not (not-correct ( + tmpL SIZE) (+ tmpC (* SIZE 2)) (+ val 1)))
				(setf possibilities (+ possibilities 1))
				(setf lastL ( + tmpL SIZE))
				(setf lastC (+ tmpC (* SIZE 2)))))
			     (T NIL)))
		      (T
		       (cond ((and (< c SIZE) (>= c 0) (zerop (aref *grid* (+ tmpL (* SIZE 2)) tmpC)))
			      (when (not (not-correct (+ tmpL (* SIZE 2)) tmpC (+ val 1)))
				(setf possibilities (+ possibilities 1))
				(setf lastL (+ tmpL (* SIZE 2)))
				(setf lastC tmpC)))
			     ((and (< c (* SIZE 2)) (>= c SIZE)(zerop (aref *grid* (+ tmpL (* SIZE 2)) (+ tmpC SIZE))))
			      (when (not (not-correct (+ tmpL (* SIZE 2)) (+ tmpC SIZE) (+ val 1)))
				(setf possibilities (+ possibilities 1))
				(setf lastL (+ tmpL (* SIZE 2)))
				(setf lastC (+ tmpC SIZE))))
			     ((and (< c AREA) (>= c (* SIZE 2)) (zerop (aref *grid* (+ tmpL (* SIZE 2)) (+ tmpC (* SIZE 2)))))
			      (when (not (not-correct (+ tmpL (* SIZE 2)) (+ tmpC (* SIZE 2)) (+ val 1)))
				(setf possibilities (+ possibilities 1))
				(setf lastL (+ tmpL (* SIZE 2)))
				(setf lastC (+ tmpC (* SIZE 2)))))
			     (T NIL))))))
	    (when (= possibilities 1)
	      (setf (aref *grid* lastL lastC) (+ val 1))
	      (return-from square-strategy T)))))))
  NIL)

;; On utilise tout à tour chaque stratégie précédente jusqu'à ce qu'aucune des trois ne trouve un chiffre
(defun int-strategy()
  (if (not (win))
      (if (or (line-strategy) (col-strategy) (square-strategy))
	  (int-strategy)
	  (progn
	    (sudoku)
	    (format t "~CLa stratégie ne trouve plus de chiffres !~C" #\linefeed #\linefeed)))
      (progn
	(sudoku)
	(format t "~CVous avez gagné, bien joué !~C" #\linefeed #\linefeed))))
